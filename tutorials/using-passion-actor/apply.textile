---
layout: default
title: passion.Actor's @apply@ and @applySorted@
permalink: apply
tutorial: using-passion-actor
---

h3. Instance methods vs class methods

Class methods are methods that are invoked directly on a class, instead of common methods, which are applied to _instances_.

Imagine that you have a @Goblin@ class defined. Say your constructor takes @x@ and @y@ as parameters. Then you would be able to create lots of goblins by invoking @Goblin:new(x,y)@ repeteadly. Each of the goblins created this way is called an _instance_ of the @Goblin@ class.

Notice that instances are also instances of any superclass of their class. So if @Goblin@ is a subclass of @passion.Actor@, then each @Goblin@ instance is also a @passion.Actor@ instance. This will be revealed of the utmost importance on the next section. For now just keep it in mind.

The goblins would probably be able to perform some actions, which could be modelled with methods, for example @attack@ or @run@. These methods would be typically executed by a single goblin:

{% highlight lua %}
-- create two goblins
local fred = Goblin:new(100,100)
local billy = Goblin:new(200,200)

-- make them do some stuff
fred:attack()
billy:run()
{% endhighlight %}

These methods executed on a single instance are called _instance methods_.

But some other methods don't quite work on a single goblin; they are more like "group actions". Consider the following:

* A method called @pauseAll@ that makes all goblins stop moving while you show a menu
* A method called @unpauseAll@ that makes them move again when the menu is gone
* A method called @checkArrow(arrow)@ that checks if an arrow has pierced any goblin

Sure, you can do a @goblin:pauseAll()@ instance method, and choose a random goblin to execute it from. But that would be quite inelegant. There's a better way: class methods.

Class methods are called directly on the class, as opposed to one of its instances:

{% highlight lua %}
Goblin:pauseAll()
Goblin:unpauseAll()
Goblin:checkArrow(arrow)
{% endhighlight %}


In MiddleClass (the library that PÄSSION uses for creating classes and instances) both kinds of methods are created in a very similar way:

{% highlight lua %}
-- Instance method
function Goblin:attack()
  -- Inside here you use "self" in order to reference the goblin instance that attacks
  ... (do the attacky stuff here)
end

-- Class method. Notice that we use . instead of : on this one!
function Goblin.pauseAll(theClass)
  -- Inside here you use "theClass" in order to reference the Goblin class itself
  ... (do the pausy stuff here)
end
{% endhighlight %}


h3. @apply@ and @applySorted@

@passion.Actor@ comes with a couple methods built-in; you will normally use them if you want to iterate over your actors in an structured way.

h4. @passion.Actor.apply(theClass, methodOrName, ...)@

This method takes 2 mandatory parameters, plus a random number of extra ones.
* The first parameter is the class you are using. This parameter is normally implied by the @:@ operator, as in Goblin:apply('pause') class
* The second parameter can be either a function, or a string. If it's a function, it will be called over all the instances of @theClass@. The first parameter of that function will be the instance being treated.
  If it's a string, it will be used as an indicator of the method to invoke. For example, the string @'pause'@ on the previous point will invoke the @goblin:pause()@ method on all instances of @Goblin@.
* Any additional parameters passed will just be added to the function calls. @Goblin:apply('pause', 1,2,3)@ will invoke @goblin:pause(1,2,3)@ on all goblins.

Note that this method takes into account subclassing; applying it on a class will have consequences on all its instances, therefore it will _include the instances of any subclasses_.

This is quite convenient for updating all actors in the system, for example. In effect, the code used in PÄSSION does (roughly) the following:

{% highlight lua %}
function passion.update(dt)
  ..
  Actor:apply('update', dt)
  ..
end
{% endhighlight %}

You can easily use it in your classes. For example, here's how I would implement the @Goblin.pauseAll@ class method:

{% highlight lua %}
function Goblin.pauseAll(theClass)
  theClass:apply('freeze')
end
{% endhighlight %}

@freeze@ is a built-in instance method (implemented on @passion.Actor@) which just freezes an instance.


h4. @passion.Actor.applySorted(theClass, sortFunc, methodOrName, ...)@

This method is a sorted version of the former; will apply the function/method in order, depending on the sorting function (which is a standard "Lua sorting":http://www.lua.org/pil/19.3.html function).

It's however slower and more memory-hungry than its unsorted counterpart.

On PÄSSION, it is used for drawing actors according to their draw order:

{% highlight lua %}
function draw()
  Actor:applySorted( _sortByDrawOrder, 'draw' )
  ...
end
{% endhighlight %}



